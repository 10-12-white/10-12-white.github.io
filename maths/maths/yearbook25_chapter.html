<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deakin Maths Chapter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Custom Palette based off: Dark Green, Dark Brown, Cream
                        'dark-green': '#1E392A',    // Main dark background
                        'dark-brown': '#3A2A1A',    // Header, footer background
                        'cream': '#FAF0DC',         // Text and title color
                        'moss-green': '#52703e',    // Project Card background
                        'deep-accent': '#C5AE87',   // Accent color (links, borders)
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-dark-green text-cream font-sans min-h-screen">

    <header class="bg-dark-brown p-4 shadow-lg">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-2xl font-bold text-deep-accent">Cryptography Project</h1>
        </div>
    </header>

    <main class="max-w-4xl mx-auto p-8">
        
        <h2 class="text-4xl font-extrabold mb-6 text-cream">Introduction</h2>
        
	
        <h3 class="text-2xl font-semibold mb-8 text-deep-accent">
            Deakin Yearbook
        </h3>

		<p>Analysis of research on lattice-based cryptography schemes, including the security and implementation of Learning With Errors (LWE) and its relationship to NP-hard problems Shortest Vector Problem (SVP) and Closest Vector Problem (CVP).  Focused on the mathematics behind the concepts, as well as next steps in my learning journey.    <a href="https://blogs.deakin.edu.au/maths/yearbook/" target="_blank">My work was done for SIT281, Cryptograpy, and is getting published in the Deakin Mathematics Yearbook of 2025, and is available here.</a></p>
        
		<h3 class="text-2xl font-semibold mb-8 text-deep-accent">
            Unabridged Sections in the Chapter
        </h3>

		<p>A section I would have loved to include in the book is a little section on LLL and BKZ, for introduction purposes:</p>

		<p>
        In my GitHub, I give examples of how the LLL algorithm can be used to find the shortest basis vector within a lattice, 
        thereby allowing us to better solve CVP and SVP <span class="citation">[work]</span>, with simple examples in 
        dimensions 2 and 3. Whilst this is useful to understand the concepts, lattice bases for encryption are at least 
        dimension \( n > 500 \). For this, we need more accurate solutions.
    </p>

    <p>
        LLL algorithm is extremely fast and often used as pre-processing; the BKZ algorithm is also accurate, but takes much, 
        much longer <span class="citation">[ias]</span>. There have been several edits to BKZ over the years, and something 
        I am particularly interested in are the edits that involve SVP Oracles. These involve SVP algorithms that can only 
        be applied to lattices with a small dimension when there are restricted resources.
    </p>

    <div class="footnote">
        <strong>Note:</strong> Why is SVP-Oracle usage interesting in BKZ? Alas, I ran out of pages. Check the GitHub or do some googling!
    </div>

    <p>
        LLL uses Gram-Schmidt Orthogonalisation as well as the Lovasz condition to reduce the basis vectors within a lattice 
        to give the smallest first, ensuring they are as orthonormal and orthogonal as possible. BKZ follows the same approach 
        but is able to give more accurate results because it applies LLL as a pre-process before "chunking" the lattice into 
        sections called <strong>blocks</strong> to further reduce with more accuracy.
    </p>

    <p>
        The block size is simply the number of vectors that we are tuning in the overall matrix that represents the lattice 
        when we try and solve for the Shortest Vector Problem. In fact, BKZ 1.0 is just LLL but with a block size of 2 (swapping 
        one row with another at a time until the complexity and continuity has been reached, repeating across the entire matrix).
    </p>

    <p>
        Three papers in particular were studied to provide a discussion on how BKZ differs from LLL with different block sizes. 
        According to <span class="citation">[dp]</span>, there have been some recent improvements with BKZ in the way that 
        block sizes are chosen.
    </p>

    <h2>Current Improvements & Open Questions</h2>

    <p>
        <em>Ok, great. Blocks help. But how many vectors should make up a block?</em> 
        The process of picking the "best" number of vectors to perform the first "mini-LLL" process on within BKZ, 
        governed by some bound \( B \), is called <strong>Discrete-Pruning Enumeration (DP-ENUM)</strong>, which was 
        formalized by <span class="citation">[dp1]</span>. They showed that the technique of choosing lattice points to 
        “sample” using the classical enumeration technique before running BKZ was a valid improvement in solving for 
        the shortest basis vector. The success probability of this "discrete pruning" was shown to be equivalent to the 
        volume of the sphere in which these subsets of vectors in the lattice existed <span class="citation">[dp1]</span>.
    </p>

    <p>
        Though that paper showed <span class="citation">[dp1]</span> that lattice enumeration and discrete pruning variants 
        could be quadratically sped up on a quantum computer, there is still an uncertain statistic on the size of the 
        "blocks" required before significant accuracy is gained over LLL, and it remains unclear when LLL becomes significantly faster. 
        Authors of <span class="citation">[dp2]</span> also indicated that one analysis is not enough to gain a good insight 
        into their accuracy, and further experimentation was needed.
    </p>

    <p>
        Recent results from <span class="citation">[dp3]</span> showed that the time it took BKZ, based on the size of the 
        modulus in Learning-With-Error (LWE) type problems, makes it clear that as the modulus increases, the growth in 
        time increases exponentially.
    </p>
		<p></p>
		<p></p>
		<p></p>
		<p></p>
		
		<h3 class="text-2xl font-semibold mb-8 text-deep-accent">
            Dedication
        </h3>
		<p>More people to dedicate it to - </p>

		<h3 class="text-2xl font-semibold mb-8 text-deep-accent">
            References
        </h3>
	
		
      </section>

		<a href="" class="inline-block py-2 px-6 bg-deep-accent text-dark-green font-bold rounded-full hover:bg-cream transition duration-300"> Back to Top</a>
</main>

	<a href="https://10-12-white.github.io/#maths" class="inline-block py-2 px-6 bg-deep-accent text-dark-green font-bold rounded-full hover:bg-cream transition duration-300"> Back to Main site</a>
</main>
	
    <footer class="bg-dark-brown text-center py-6 border-t border-deep-accent">
        <p class="text-sm text-cream opacity-70">&copy; 2025 TWhite | All Rights Reserved.</p>
    </footer>

    <!-- Initialize Lucide Icons --><script>
        lucide.createIcons();
    </script>
</body>
</html>
